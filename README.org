*RT SIMULATE*

* DONE implement the worst case response time algorithm
  CLOSED: [2009-08-31 Mon 09:31]
  - CLOSING NOTE [2009-08-31 Mon 09:31] \\
    Algorithm working on simple cases

* TODO write the graphical interface with wxWidget

* TODO test deeply all the possible error conditions


* General concepts

This program will show interactively how some real time algorithms work.
It works as:
1. task a set of tasks as input
2. choose a scheduling algorithm
3. check if is schedulable or not
4. return the scheduled hyperperiod if possible

Tasks are taken from the command line or from a configuration file.

In plus there will be an interactive modality (cli or GUI) where those operations should be possible:
- add a new task
- remove a task
- see the timeline

[[http://dit.unitn.it/~abeni/RTOS/index.html][This]] is the official site, more information on laboratories [[http://dit.unitn.it/~abeni/RTOS/lab.html][here]].

Using a MVC pattern to design the application, which must be easily adapt to new algorithms and data types.

* Languages used
  - python (for the gui and control interface)
  - C/pyrex extension (for the algorithm engine)

* Frameworks
  - wxgtk/gtk/dialog?
  - [[http://wiki.wxpython.org/How%20to%20Learn%20wxPython][How to learn wxpython]]
    
* Language table

  |------------+------------------------------|
  | Task       | Schedulable entity           |
  | Preemptive | OS can regain control of cpu |
  | WCET       | Worst Case Execution Time    |

* Theory summary
  OS kernel creates the illusion of multiple CPUs, concurrency is implemented by multiplexing tasks.
  Tasks are associated to temporal constraints (*deadlines*)
  
  Scheduler is responsible for selecting the tasks to execute.
  
Algorithms:
** STATIC scheduling algorithm
   - Time axis divided in time slots
   - Slots statically allocated to the tasks
   - $\tau$ = *gcd*, $T$ = *lcm*
   - Very simple implementation, no operating system needed

     *NOT VERY CLEAR HOW TO IMPLEMENT THIS, only frequencies and timings in the slides.*
     What's the deadline in this case?
     In general enough to fire a timer every *minor cycle*.

** Fixed priority scheduling
   Very simple /preemptive/ scheduling algorithm.
   - every task has a fixed priority p_i
   - active task with highest priority are scheduled

     To have a better response of the system the priority must be chosen dynamically.
     So the problem becomes, how to assign priorities to manage to have a schedulable set of tasks?

** Dynamic priority scheduling algorithms:
   Given a set, how to assign priorities?
   Two possible objectives:
   - schedulability
   - response time
      
   - Given a set of tasks where all periods are equal to deadlines and offsets equal to 0.
      ($\forall i, D_i = T_i
     \forall i, r_i0 = 0$)
     [[rate][rate monotonic]] is the best choice

   - Given a set of tasks where all periods are different from deadlines
     [[dead][deadline monotonic]] is the best choice
     
     If we consider periodic tasks with offsets, then /there is no optimal priority assignment possible/

#<<dead>>
*** Deadline monotonic
    Shorter period $\rightarrow$ higher priority.

#<<rate>>
*** Rate monotonic
    Shorter relative deadline $\rightarrow$ higher priority.

** Analysis
   Given a set of tasks, how can we make sure that is possible to schedule them?
   
   1. simulate the system to check if deadlines missed:
      /hyperperiod/ ($H = lcm\{Ti\}$)
      *The number can be very large*

   2. *Utilisation analysis for RM*:
      
      Based on the utilisation bound, only works for deadline monotonic case (deadline = period)

      Each task uses the processor:
      $Ui = Ci/Ti$
      
      Total processor utilisation is:
      $U = \sum_i Ci/Ti$
      
      So we get:
      $U > 1 \rightarrow$ not schedulable
      $U < Ulub \rightarrow$ schedulable
      $U < 1 \rightarrow$ don't know, other checks needed

      $Ulub = 1$ would be optimal

   3. *Utilisation analysis for DM*:
      In this case we consider
      $U' = \sum_i Ci/Di$
      $\tau = (C,D,D)$ is the worst possible case of $\tau = (C,D,T)$
      So if one is satisfied the other is also satisfied
      
      This bound is very pessimistic.

   4. *Response time analysis*:
      Compute the /worst case response time/ for every task.
      Valid for an arbitrary assignment.
      Assumes periodic tasks with no offsets.
      
      *Critical instant*: job $Ji,j$ is released at the same time with a job in every high priority task
      
